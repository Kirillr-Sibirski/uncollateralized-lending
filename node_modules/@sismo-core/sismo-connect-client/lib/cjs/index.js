'use strict';

var pako = require('pako');
var jsBase64 = require('js-base64');
var viem = require('viem');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var SISMO_CONNECT_VERSION = "sismo-connect-v1.1";
exports.Vault = void 0;
(function (Vault) {
    Vault["Main"] = "main";
    Vault["Dev"] = "dev";
    Vault["Demo"] = "demo";
})(exports.Vault || (exports.Vault = {}));
exports.ProvingScheme = void 0;
(function (ProvingScheme) {
    ProvingScheme["HYDRA_S2"] = "hydra-s2.1";
    ProvingScheme["HYDRA_S3"] = "hydra-s3.1";
})(exports.ProvingScheme || (exports.ProvingScheme = {}));
exports.ClaimType = void 0;
(function (ClaimType) {
    ClaimType[ClaimType["GTE"] = 0] = "GTE";
    ClaimType[ClaimType["GT"] = 1] = "GT";
    ClaimType[ClaimType["EQ"] = 2] = "EQ";
    ClaimType[ClaimType["LT"] = 3] = "LT";
    ClaimType[ClaimType["LTE"] = 4] = "LTE";
})(exports.ClaimType || (exports.ClaimType = {}));
exports.AuthType = void 0;
(function (AuthType) {
    AuthType[AuthType["VAULT"] = 0] = "VAULT";
    AuthType[AuthType["GITHUB"] = 1] = "GITHUB";
    AuthType[AuthType["TWITTER"] = 2] = "TWITTER";
    AuthType[AuthType["EVM_ACCOUNT"] = 3] = "EVM_ACCOUNT";
    AuthType[AuthType["TELEGRAM"] = 4] = "TELEGRAM";
})(exports.AuthType || (exports.AuthType = {}));
var SismoConnectVerifiedResult = /** @class */ (function () {
    function SismoConnectVerifiedResult(_a) {
        var response = _a.response, claims = _a.claims, auths = _a.auths;
        this.response = response;
        this.claims = claims;
        this.auths = auths;
        this.signedMessage = response.signedMessage;
    }
    SismoConnectVerifiedResult.prototype.getUserId = function (authType) {
        var _a;
        var userId = (_a = this.auths.find(function (verifiedAuth) { return verifiedAuth.authType === authType; })) === null || _a === void 0 ? void 0 : _a.userId;
        return resolveSismoIdentifier(userId, authType);
    };
    SismoConnectVerifiedResult.prototype.getUserIds = function (authType) {
        return this.auths
            .filter(function (verifiedAuth) { return verifiedAuth.authType === authType && verifiedAuth.userId; })
            .map(function (auth) { return resolveSismoIdentifier(auth.userId, authType); });
    };
    SismoConnectVerifiedResult.prototype.getSignedMessage = function () {
        return this.signedMessage;
    };
    return SismoConnectVerifiedResult;
}());
var startsWithHexadecimal = function (str) {
    var hexRegex = /^0x[0-9a-fA-F]{6}/;
    return hexRegex.test(str);
};
var resolveSismoIdentifier = function (sismoIdentifier, authType) {
    if (authType === exports.AuthType.EVM_ACCOUNT || authType === exports.AuthType.VAULT)
        return sismoIdentifier;
    if (!startsWithHexadecimal(sismoIdentifier))
        return sismoIdentifier;
    var removeLeadingZeros = function (str) {
        var arr = str.split("");
        while (arr.length > 1 && arr[0] === "0") {
            arr.shift();
        }
        return arr.join("");
    };
    sismoIdentifier = sismoIdentifier.substring(6);
    sismoIdentifier = removeLeadingZeros(sismoIdentifier);
    return sismoIdentifier;
};
var toSismoIdentifier = function (identifier, authType) {
    if (authType === exports.AuthType.EVM_ACCOUNT || authType === exports.AuthType.VAULT)
        return identifier;
    if (startsWithHexadecimal(identifier))
        return identifier;
    var prefix = "";
    if (authType === exports.AuthType.GITHUB) {
        prefix = "0x1001";
    }
    if (authType === exports.AuthType.TWITTER) {
        prefix = "0x1002";
    }
    if (authType === exports.AuthType.TELEGRAM) {
        prefix = "0x1003";
    }
    identifier = "0".repeat(36 - identifier.length) + identifier;
    identifier = prefix + identifier;
    return identifier;
};
var RequestBuilder = /** @class */ (function () {
    function RequestBuilder() {
    }
    RequestBuilder.buildAuths = function (auths) {
        var _a, _b, _c, _d;
        if (!auths) {
            return [];
        }
        if (!auths.length) {
            auths = [auths];
        }
        auths = auths;
        for (var _i = 0, auths_1 = auths; _i < auths_1.length; _i++) {
            var authRequest = auths_1[_i];
            if (authRequest.isAnon)
                throw new Error("isAnon not supported yet");
            if (typeof authRequest.authType === undefined) {
                throw new Error("you must provide a authType");
            }
            authRequest.isAnon = false;
            authRequest.isOptional = (_a = authRequest.isOptional) !== null && _a !== void 0 ? _a : false;
            authRequest.userId = (_b = authRequest.userId) !== null && _b !== void 0 ? _b : "0";
            if (authRequest.authType === exports.AuthType.EVM_ACCOUNT) {
                authRequest.userId = authRequest.userId.toLowerCase();
            }
            authRequest.extraData = (_c = authRequest.extraData) !== null && _c !== void 0 ? _c : "";
            if (authRequest.userId === "0") {
                authRequest.isSelectableByUser = (_d = authRequest.isSelectableByUser) !== null && _d !== void 0 ? _d : true;
            }
            else {
                authRequest.isSelectableByUser = false;
            }
            if (authRequest.authType === exports.AuthType.VAULT) {
                authRequest.isSelectableByUser = false;
                authRequest.userId = "0";
            }
            if (authRequest.userId !== "0") {
                authRequest.userId = toSismoIdentifier(authRequest.userId, authRequest.authType);
            }
        }
        return auths;
    };
    RequestBuilder.buildClaims = function (claims) {
        var _a, _b, _c, _d;
        if (!claims) {
            return [];
        }
        if (claims === null || claims === void 0 ? void 0 : claims.groupId) {
            claims = [claims];
        }
        claims = claims;
        for (var _i = 0, claims_1 = claims; _i < claims_1.length; _i++) {
            var claimRequest = claims_1[_i];
            if (typeof claimRequest.claimType === undefined) {
                throw new Error("you must provide a claimType");
            }
            if (typeof claimRequest.groupId === undefined) {
                throw new Error("you must provide a groupId");
            }
            claimRequest.claimType = (_a = claimRequest.claimType) !== null && _a !== void 0 ? _a : exports.ClaimType.GTE;
            claimRequest.extraData = (_b = claimRequest.extraData) !== null && _b !== void 0 ? _b : "";
            claimRequest.groupTimestamp = (_c = claimRequest.groupTimestamp) !== null && _c !== void 0 ? _c : "latest";
            claimRequest.value = (_d = claimRequest.value) !== null && _d !== void 0 ? _d : 1;
        }
        return claims;
    };
    RequestBuilder.buildSignature = function (signature) {
        var _a, _b;
        if (!signature) {
            return null;
        }
        if (typeof signature.message === undefined) {
            throw new Error("you must provide a message");
        }
        signature.isSelectableByUser = (_a = signature.isSelectableByUser) !== null && _a !== void 0 ? _a : false;
        signature.extraData = (_b = signature.extraData) !== null && _b !== void 0 ? _b : "";
        return signature;
    };
    return RequestBuilder;
}());

var getGroupFromIdQuery = "\n  query getGroup($id: ID!) {\n    group(id: $id) {\n      id\n      name\n      description\n      specs\n      generationFrequency\n      snapshots {\n        timestamp\n        dataUrl\n      }\n    }\n  }\n";
var getGroupFromNameQuery = "\n  query getGroup($name: String!) {\n    group(name: $name) {\n      id\n      name\n      description\n      specs\n      generationFrequency\n      snapshots {\n        timestamp\n        dataUrl\n      }\n    }\n  }\n";

var ApiFetcher = /** @class */ (function () {
    function ApiFetcher(url) {
        this._url = url;
    }
    ApiFetcher.prototype.getWithQuery = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fetch(this._url, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({
                                query: opts.query,
                                variables: opts.variables,
                            }),
                        })
                            .then(function (res) { return res.json(); })
                            .then(function (res) { return res.data; })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return ApiFetcher;
}());

var sismoApiUrls = {
    staging: "https://api.staging.zikies.io",
    testnets: "https://api.testnets.sismo.io",
    prod: "https://api.sismo.io",
};

var Sdk = /** @class */ (function () {
    function Sdk(sismoApiUrl) {
        this._apiFetcher = new ApiFetcher(sismoApiUrl !== null && sismoApiUrl !== void 0 ? sismoApiUrl : sismoApiUrls.prod);
    }
    Sdk.prototype.getGroup = function (_a) {
        var id = _a.id, name = _a.name, timestamp = _a.timestamp;
        return __awaiter(this, void 0, void 0, function () {
            var group, _b, dataUrl, snapshot, data;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!id && !name) {
                            throw new Error("Either id or name must be provided for the group. You can view all groups at https://factory.sismo.io/groups-explorer.");
                        }
                        if (!id) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._apiFetcher.getWithQuery({
                                query: getGroupFromIdQuery,
                                variables: { id: id },
                            })];
                    case 1:
                        _b = (_c.sent()).group;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this._apiFetcher.getWithQuery({
                            query: getGroupFromNameQuery,
                            variables: { name: name },
                        })];
                    case 3:
                        _b = (_c.sent()).group;
                        _c.label = 4;
                    case 4:
                        group = _b;
                        if (timestamp) {
                            snapshot = group.snapshots.filter(function (s) { return s.timestamp === timestamp; })[0];
                            (dataUrl = snapshot.dataUrl);
                            if (!snapshot) {
                                (dataUrl = group.snapshots[0].dataUrl);
                            }
                        }
                        else {
                            (dataUrl = group.snapshots[0].dataUrl);
                        }
                        return [4 /*yield*/, fetch(dataUrl).then(function (res) { return res.json(); })];
                    case 5:
                        data = _c.sent();
                        return [2 /*return*/, __assign(__assign({}, group), { data: data })];
                }
            });
        });
    };
    return Sdk;
}());

var MAIN_VAULT_APP_BASE_URL = "https://vault-beta.sismo.io";
var IMPERSONATION_VAULT_APP_BASE_URL = "https://vault-beta.sismo.io";

var unCompressResponse = function (data) { return pako.ungzip(jsBase64.toUint8Array(data), { to: "string" }); };

var toBytes16 = function (data) {
    if (viem.isHex(data))
        return viem.pad(data, { size: 16 });
    else
        return viem.sliceHex(viem.keccak256(hexlify(data)), 0, 16);
};
var toBytes32 = function (data) {
    return viem.pad(hexlify(data), { size: 32, dir: "right" });
};
var toBytes = function (data) {
    return viem.toHex(viem.toBytes(data));
};
var hexlify = function (data) {
    return viem.isHex(data) ? data : viem.toHex(data);
};
var formatResponseToEncode = function (sismoConnectResponse) {
    var _a, _b;
    return {
        appId: toBytes16(sismoConnectResponse.appId),
        namespace: toBytes16((_a = sismoConnectResponse === null || sismoConnectResponse === void 0 ? void 0 : sismoConnectResponse.namespace) !== null && _a !== void 0 ? _a : "main"),
        version: toBytes32(sismoConnectResponse.version),
        signedMessage: (sismoConnectResponse === null || sismoConnectResponse === void 0 ? void 0 : sismoConnectResponse.signedMessage)
            ? hexlify(sismoConnectResponse.signedMessage)
            : toBytes("0x0000000000000000000000000000000000000000000000000000000000000000"),
        proofs: (_b = sismoConnectResponse.proofs) === null || _b === void 0 ? void 0 : _b.map(function (proof) {
            var _a, _b, _c, _d, _e, _f;
            return {
                claims: (_b = (_a = proof.claims) === null || _a === void 0 ? void 0 : _a.map(function (claim) {
                    var _a, _b, _c, _d, _e, _f, _g;
                    return {
                        groupId: toBytes16((_a = claim.groupId) !== null && _a !== void 0 ? _a : "0x00"),
                        groupTimestamp: !((_b = proof === null || proof === void 0 ? void 0 : proof.claims[0]) === null || _b === void 0 ? void 0 : _b.groupTimestamp) || ((_c = proof === null || proof === void 0 ? void 0 : proof.claims[0]) === null || _c === void 0 ? void 0 : _c.groupTimestamp) === "latest"
                            ? viem.pad(hexlify("latest"), { size: 16, dir: "right" })
                            : toBytes((_d = proof === null || proof === void 0 ? void 0 : proof.claims[0]) === null || _d === void 0 ? void 0 : _d.groupTimestamp),
                        claimType: claim.claimType,
                        isSelectableByUser: (_e = claim === null || claim === void 0 ? void 0 : claim.isSelectableByUser) !== null && _e !== void 0 ? _e : false,
                        value: BigInt((_f = claim.value) !== null && _f !== void 0 ? _f : 1),
                        extraData: toBytes((_g = claim.extraData) !== null && _g !== void 0 ? _g : ""),
                    };
                })) !== null && _b !== void 0 ? _b : [],
                auths: (_d = (_c = proof.auths) === null || _c === void 0 ? void 0 : _c.map(function (auth) {
                    var _a, _b, _c, _d;
                    return {
                        authType: auth === null || auth === void 0 ? void 0 : auth.authType,
                        isAnon: (_a = auth === null || auth === void 0 ? void 0 : auth.isAnon) !== null && _a !== void 0 ? _a : false,
                        isSelectableByUser: (_b = auth === null || auth === void 0 ? void 0 : auth.isSelectableByUser) !== null && _b !== void 0 ? _b : false,
                        userId: BigInt((_c = auth === null || auth === void 0 ? void 0 : auth.userId) !== null && _c !== void 0 ? _c : 0),
                        extraData: toBytes((_d = auth.extraData) !== null && _d !== void 0 ? _d : ""),
                    };
                })) !== null && _d !== void 0 ? _d : [],
                proofData: proof.proofData,
                provingScheme: toBytes32((_e = proof === null || proof === void 0 ? void 0 : proof.provingScheme) !== null && _e !== void 0 ? _e : "hydra-s3.1"),
                extraData: toBytes((_f = proof.extraData) !== null && _f !== void 0 ? _f : ""),
            };
        }),
    };
};
var toSismoConnectResponseBytes = function (sismoConnectResponse) {
    if (!sismoConnectResponse)
        return null;
    return viem.encodeAbiParameters([
        {
            components: [
                {
                    internalType: "bytes16",
                    name: "appId",
                    type: "bytes16",
                },
                {
                    internalType: "bytes16",
                    name: "namespace",
                    type: "bytes16",
                },
                {
                    internalType: "bytes32",
                    name: "version",
                    type: "bytes32",
                },
                {
                    internalType: "bytes",
                    name: "signedMessage",
                    type: "bytes",
                },
                {
                    components: [
                        {
                            components: [
                                {
                                    internalType: "enum AuthType",
                                    name: "authType",
                                    type: "uint8",
                                },
                                {
                                    internalType: "bool",
                                    name: "isAnon",
                                    type: "bool",
                                },
                                {
                                    internalType: "bool",
                                    name: "isSelectableByUser",
                                    type: "bool",
                                },
                                {
                                    internalType: "uint256",
                                    name: "userId",
                                    type: "uint256",
                                },
                                {
                                    internalType: "bytes",
                                    name: "extraData",
                                    type: "bytes",
                                },
                            ],
                            internalType: "struct Auth[]",
                            name: "auths",
                            type: "tuple[]",
                        },
                        {
                            components: [
                                {
                                    internalType: "enum ClaimType",
                                    name: "claimType",
                                    type: "uint8",
                                },
                                {
                                    internalType: "bytes16",
                                    name: "groupId",
                                    type: "bytes16",
                                },
                                {
                                    internalType: "bytes16",
                                    name: "groupTimestamp",
                                    type: "bytes16",
                                },
                                {
                                    internalType: "bool",
                                    name: "isSelectableByUser",
                                    type: "bool",
                                },
                                {
                                    internalType: "uint256",
                                    name: "value",
                                    type: "uint256",
                                },
                                {
                                    internalType: "bytes",
                                    name: "extraData",
                                    type: "bytes",
                                },
                            ],
                            internalType: "struct Claim[]",
                            name: "claims",
                            type: "tuple[]",
                        },
                        {
                            internalType: "bytes32",
                            name: "provingScheme",
                            type: "bytes32",
                        },
                        {
                            internalType: "bytes",
                            name: "proofData",
                            type: "bytes",
                        },
                        {
                            internalType: "bytes",
                            name: "extraData",
                            type: "bytes",
                        },
                    ],
                    internalType: "struct SismoConnectProof[]",
                    name: "proofs",
                    type: "tuple[]",
                },
            ],
            internalType: "struct SismoConnectResponse",
            name: "response",
            type: "tuple",
        },
    ], [formatResponseToEncode(sismoConnectResponse)]);
};

var SismoConnect = function (_a) {
    var config = _a.config;
    return new SismoConnectClient({ config: config });
};
var SismoConnectClient = /** @class */ (function () {
    function SismoConnectClient(_a) {
        var config = _a.config;
        var _this = this;
        var _b, _c, _d;
        this.request = function (_a) {
            var claims = _a.claims, claim = _a.claim, auths = _a.auths, auth = _a.auth, signature = _a.signature, namespace = _a.namespace, callbackPath = _a.callbackPath, callbackUrl = _a.callbackUrl;
            if (!window)
                throw new Error("requestProof is not available outside of a browser");
            if (!callbackUrl) {
                callbackUrl = window.location.origin + window.location.pathname;
            }
            var url = _this.getRequestLink({
                claims: claims,
                claim: claim,
                auths: auths,
                auth: auth,
                signature: signature,
                namespace: namespace,
                callbackPath: callbackPath,
                callbackUrl: callbackUrl,
            });
            window.location.href = encodeURI(url);
        };
        this.getRequestLink = function (_a) {
            var _b, _c;
            var claims = _a.claims, claim = _a.claim, auths = _a.auths, auth = _a.auth, signature = _a.signature, namespace = _a.namespace, callbackPath = _a.callbackPath, callbackUrl = _a.callbackUrl;
            if (!claims && !auths && !signature && !claim && !auth) {
                throw new Error("claims or auths or signature is required");
            }
            if (auths && auth) {
                throw new Error("You can't use both auth and auths");
            }
            if (claims && claim) {
                throw new Error("You can't use both claim and claims");
            }
            var url = "".concat(_this._sismoConnectConfig.vaultAppBaseUrl, "/connect?version=").concat(SISMO_CONNECT_VERSION, "&appId=").concat(_this._sismoConnectConfig.appId);
            if (claims) {
                url += "&claims=".concat(JSON.stringify(RequestBuilder.buildClaims(claims)));
            }
            if (claim) {
                url += "&claims=".concat(JSON.stringify(RequestBuilder.buildClaims(claim)));
            }
            if (auths) {
                url += "&auths=".concat(JSON.stringify(RequestBuilder.buildAuths(auths)));
            }
            if (auth) {
                url += "&auths=".concat(JSON.stringify(RequestBuilder.buildAuths(auth)));
            }
            if (signature) {
                signature = RequestBuilder.buildSignature(signature);
                url += "&signature=".concat(JSON.stringify(signature));
            }
            if (((_c = (_b = _this._sismoConnectConfig.vault) === null || _b === void 0 ? void 0 : _b.impersonate) === null || _c === void 0 ? void 0 : _c.length) > 0) {
                url += "&vault=".concat(JSON.stringify(_this._sismoConnectConfig.vault));
            }
            if (_this._sismoConnectConfig.displayRawResponse) {
                url += "&displayRawResponse=true";
            }
            if (callbackPath) {
                url += "&callbackPath=".concat(callbackPath);
            }
            if (namespace) {
                url += "&namespace=".concat(namespace);
            }
            if (callbackUrl) {
                url += "&callbackUrl=".concat(callbackUrl);
            }
            url += "&compressed=true";
            return url;
        };
        this.getResponse = function () {
            if (!window)
                throw new Error("getResponse is not available outside of a browser");
            var url = new URL(window.location.href);
            if (url.searchParams.has("sismoConnectResponseCompressed")) {
                var compressedResponse = url.searchParams.get("sismoConnectResponseCompressed");
                var uncompressedResponse = unCompressResponse(compressedResponse);
                return JSON.parse(uncompressedResponse);
            }
            return null;
        };
        this.getResponseBytes = function () {
            if (!window)
                throw new Error("getResponse is not available outside of a browser");
            var url = new URL(window.location.href);
            if (url.searchParams.has("sismoConnectResponseCompressed")) {
                var compressedResponse = url.searchParams.get("sismoConnectResponseCompressed");
                var uncompressedResponse = unCompressResponse(compressedResponse);
                var sismoConnectResponse = JSON.parse(uncompressedResponse);
                return toSismoConnectResponseBytes(sismoConnectResponse);
            }
            return null;
        };
        if (!config) {
            throw new Error("No SismoConnect config provided.");
        }
        config.vault = (_b = config.vault) !== null && _b !== void 0 ? _b : { impersonate: [] };
        this._sismoConnectConfig = config;
        var isImpersonationMode = ((_d = (_c = this._sismoConnectConfig.vault) === null || _c === void 0 ? void 0 : _c.impersonate) === null || _d === void 0 ? void 0 : _d.length) > 0;
        if (!this._sismoConnectConfig.vaultAppBaseUrl) {
            if (isImpersonationMode) {
                this._sismoConnectConfig.vaultAppBaseUrl = IMPERSONATION_VAULT_APP_BASE_URL;
            }
            else {
                this._sismoConnectConfig.vaultAppBaseUrl = MAIN_VAULT_APP_BASE_URL;
            }
        }
        if (!this._sismoConnectConfig.displayRawResponse) {
            this._sismoConnectConfig.displayRawResponse = false;
        }
        this._sdk = new Sdk(this._sismoConnectConfig.sismoApiUrl);
    }
    SismoConnectClient.prototype.getGroup = function (_a) {
        var id = _a.id, name = _a.name, timestamp = _a.timestamp;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                return [2 /*return*/, this._sdk.getGroup({ id: id, name: name, timestamp: timestamp })];
            });
        });
    };
    return SismoConnectClient;
}());

// ABI of all the errors that can be thrown by the contract inheriting Sismo Connect
var sismoConnectErrorsABI = [
    {
        // SismoConnectVerifier errors
        inputs: [
            {
                internalType: "bytes16",
                name: "receivedAppId",
                type: "bytes16",
            },
            {
                internalType: "bytes16",
                name: "expectedAppId",
                type: "bytes16",
            },
        ],
        name: "AppIdMismatch",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "bytes16",
                name: "receivedNamespace",
                type: "bytes16",
            },
            {
                internalType: "bytes16",
                name: "expectedNamespace",
                type: "bytes16",
            },
        ],
        name: "NamespaceMismatch",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "requestVersion",
                type: "bytes32",
            },
            {
                internalType: "bytes32",
                name: "responseVersion",
                type: "bytes32",
            },
        ],
        name: "VersionMismatch",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "requestMessageSignature",
                type: "bytes",
            },
            {
                internalType: "bytes",
                name: "responseMessageSignature",
                type: "bytes",
            },
        ],
        type: "error",
        name: "SignatureMessageMismatch",
    },
    // HydraS2Verifier errors
    {
        inputs: [
            {
                internalType: "uint256",
                name: "claimTypeFromProof",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "expectedClaimType",
                type: "uint256",
            },
        ],
        name: "ClaimTypeMismatch",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "claimTypeFromProof",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "expectedClaimType",
                type: "uint256",
            },
        ],
        name: "ClaimTypeMismatch",
        type: "error",
    },
    {
        inputs: [],
        name: "ClaimValueMismatch",
        type: "error",
    },
    {
        inputs: [],
        name: "OnlyOneAuthAndOneClaimIsSupported",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "version",
                type: "bytes32",
            },
        ],
        name: "InvalidVersion",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "userIdFromProof",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "expectedUserId",
                type: "uint256",
            },
        ],
        name: "UserIdMismatch",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "inputRoot",
                type: "uint256",
            },
        ],
        name: "RegistryRootNotAvailable",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "vaultNamespaceFromProof",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "expectedVaultNamespace",
                type: "uint256",
            },
        ],
        name: "VaultNamespaceMismatch",
        type: "error",
    },
    {
        inputs: [],
        name: "DestinationVerificationNotEnabled",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "extraDataFromProof",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "expectedExtraData",
                type: "uint256",
            },
        ],
        name: "InvalidExtraData",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "requestIdentifierFromProof",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "expectedRequestIdentifier",
                type: "uint256",
            },
        ],
        name: "RequestIdentifierMismatch",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "expectedX",
                type: "bytes32",
            },
            {
                internalType: "bytes32",
                name: "expectedY",
                type: "bytes32",
            },
            {
                internalType: "bytes32",
                name: "inputX",
                type: "bytes32",
            },
            {
                internalType: "bytes32",
                name: "inputY",
                type: "bytes32",
            },
        ],
        name: "CommitmentMapperPubKeyMismatch",
        type: "error",
    },
    {
        inputs: [],
        name: "SourceVerificationNotEnabled",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "destinationFromProof",
                type: "address",
            },
            {
                internalType: "address",
                name: "expectedDestination",
                type: "address",
            },
        ],
        name: "DestinationMismatch",
        type: "error",
    },
    {
        inputs: [],
        name: "InvalidProof",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "accountsTreeValueFromProof",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "expectedAccountsTreeValue",
                type: "uint256",
            },
        ],
        name: "AccountsTreeValueMismatch",
        type: "error",
    },
    // ClaimMatching errors
    {
        inputs: [
            {
                internalType: "bytes16",
                name: "requestClaimGroupId",
                type: "bytes16",
            },
            {
                internalType: "bytes16",
                name: "requestClaimGroupTimestamp",
                type: "bytes16",
            },
        ],
        name: "ClaimGroupIdAndGroupTimestampNotFound",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "bytes16",
                name: "requestClaimGroupId",
                type: "bytes16",
            },
        ],
        name: "ClaimGroupIdNotFound",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "bytes16",
                name: "requestClaimGroupTimestamp",
                type: "bytes16",
            },
        ],
        name: "ClaimGroupTimestampNotFound",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint8",
                name: "responseClaimType",
                type: "uint8",
            },
            {
                internalType: "bytes16",
                name: "responseClaimGroupId",
                type: "bytes16",
            },
            {
                internalType: "bytes16",
                name: "responseClaimGroupTimestamp",
                type: "bytes16",
            },
            {
                internalType: "uint256",
                name: "responseClaimValue",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "responseExtraData",
                type: "bytes",
            },
        ],
        name: "ClaimInRequestNotFoundInResponse",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint8",
                name: "requestClaimType",
                type: "uint8",
            },
            {
                internalType: "bytes16",
                name: "requestClaimGroupId",
                type: "bytes16",
            },
        ],
        name: "ClaimTypeAndGroupIdNotFound",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint8",
                name: "requestClaimType",
                type: "uint8",
            },
            {
                internalType: "bytes16",
                name: "requestClaimGroupTimestamp",
                type: "bytes16",
            },
        ],
        name: "ClaimTypeAndGroupTimestampNotFound",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint8",
                name: "requestClaimType",
                type: "uint8",
            },
        ],
        name: "ClaimTypeNotFound",
        type: "error",
    },
    // AuthMatchingLib errors
    {
        inputs: [
            {
                internalType: "uint8",
                name: "requestAuthType",
                type: "uint8",
            },
            {
                internalType: "bool",
                name: "requestIsAnon",
                type: "bool",
            },
            {
                internalType: "uint256",
                name: "requestUserId",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "requestExtraData",
                type: "bytes",
            },
        ],
        name: "AuthInRequestNotFoundInResponse",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "bool",
                name: "requestIsAnon",
                type: "bool",
            },
            {
                internalType: "uint256",
                name: "requestUserId",
                type: "uint256",
            },
        ],
        name: "AuthIsAnonAndUserIdNotFound",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "bool",
                name: "requestIsAnon",
                type: "bool",
            },
        ],
        name: "AuthIsAnonNotFound",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint8",
                name: "requestAuthType",
                type: "uint8",
            },
            {
                internalType: "bool",
                name: "requestIsAnon",
                type: "bool",
            },
        ],
        name: "AuthTypeAndIsAnonNotFound",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint8",
                name: "requestAuthType",
                type: "uint8",
            },
            {
                internalType: "uint256",
                name: "requestUserId",
                type: "uint256",
            },
        ],
        name: "AuthTypeAndUserIdNotFound",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint8",
                name: "requestAuthType",
                type: "uint8",
            },
        ],
        name: "AuthTypeNotFound",
        type: "error",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "requestUserId",
                type: "uint256",
            },
        ],
        name: "AuthUserIdNotFound",
        type: "error",
    },
];

exports.ApiFetcher = ApiFetcher;
exports.IMPERSONATION_VAULT_APP_BASE_URL = IMPERSONATION_VAULT_APP_BASE_URL;
exports.MAIN_VAULT_APP_BASE_URL = MAIN_VAULT_APP_BASE_URL;
exports.RequestBuilder = RequestBuilder;
exports.SISMO_CONNECT_VERSION = SISMO_CONNECT_VERSION;
exports.Sdk = Sdk;
exports.SismoConnect = SismoConnect;
exports.SismoConnectClient = SismoConnectClient;
exports.SismoConnectVerifiedResult = SismoConnectVerifiedResult;
exports.getGroupFromIdQuery = getGroupFromIdQuery;
exports.getGroupFromNameQuery = getGroupFromNameQuery;
exports.resolveSismoIdentifier = resolveSismoIdentifier;
exports.sismoApiUrls = sismoApiUrls;
exports.sismoConnectErrorsABI = sismoConnectErrorsABI;
exports.toSismoIdentifier = toSismoIdentifier;
//# sourceMappingURL=index.js.map
